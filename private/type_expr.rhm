#lang rhombus/static/and_meta
import:
  meta:
    "type.rhm" as t
    "box.rhm" open
    "id_map.rhm" open
  "type_statinfo.rhm" as t_s

space.enforest type_expr:
  space_path shplait/type
  macro_definer macro
  meta_namespace type_expr_meta:
    description "type"
    reflection space
    parse_syntax_class Parsed
    parse_infix_more_syntax_class AfterInfixParsed
    parsed_packer _pack
    parsed_unpacker _unpack
    identifier_parser: fun(stx):
                         current_type_lookup()(stx)
                           || syntax_meta.error("expected a type", stx)
    parse_checker: fun (stx, proc):
                     if _unpack(stx, fun (_): #false)
                     | stx
                     | match stx
                       | '$(t :: type_expr_meta.Parsed)': t
    export:
      pack
      unpack
    fun pack(t :: t.Type):
      let pk = _pack(t_s.type_to_syntax(t))
      if t.src is_a Syntax
      | Syntax.relocate(pk, t.src)
      | pk
    fun unpack(stx):
      t_s.syntax_to_type(_unpack(stx))

export:
  only_space type_expr:
    Number
    String
    Boolean
    Syntax
    Symbol
    Void
    #'
    Listof
    #%parens
    ->
    *

module define:
  export:
    type_expr
    meta:
      type_expr_meta

module parse:
  export:
    meta:
      parse
      current_tvars_box

meta:
  def current_tvars_box = Parameter.make(IdMap{})
  def current_type_lookup = Parameter.make(fun (_): #false)
  def current_tvar_lookup = Parameter.make(fun (_): #false)
  
  syntax_class ParsedType:
    fields: type
    kind: ~group
  | '$(tp :: type_expr_meta.Parsed)':
      field type:
        extract_parsed(tp)

  fun extract_parsed(tp):
    match type_expr_meta.unpack(tp)
    | _ :: t.ParenOf:
        syntax_meta.error("parenthesized types without `->` afterward", tp)
    | ty: ty

type_expr.macro 'Number':
  ~op_stx self
  type_expr_meta.pack(t.Num(self))

type_expr.macro 'String':
  ~op_stx self
  type_expr_meta.pack(t.Str(self))

type_expr.macro 'Boolean':
  ~op_stx self
  type_expr_meta.pack(t.Bool(self))

type_expr.macro 'Symbol':
  ~op_stx self
  type_expr_meta.pack(t.Sym(self))

type_expr.macro 'Syntax':
  ~op_stx self
  type_expr_meta.pack(t.Shrub(self))

type_expr.macro 'Void':
  ~op_stx self
  type_expr_meta.pack(t.Bool(self))

type_expr.macro '#' $(id :: Identifier)':
  ~op_stx self
  let tvars_box :: Box = current_tvars_box()
  let tvars :: IdMap = tvars_box.val
  let tv:
    tvars[id]
      || current_tvar_lookup()(id)
      || (block:
            let tv = t.gen_tvar('$self $id')
            tvars_box.val := tvars ++ IdMap{id: tv}
            tv)
  type_expr_meta.pack(tv)

type_expr.macro 'Listof ($(elem :: ParsedType))':
  ~op_stx self
  type_expr_meta.pack(t.ListOf(self, elem.type))

type_expr.macro
| '#%parens ($(elem :: ParsedType))':
    type_expr_meta.pack(elem.type)
| '#%parens $(args && '($(elem :: ParsedType), ...)')':
    ~op_stx self
    type_expr_meta.pack(t.ParenOf(args, [elem.type, ...]))  

type_expr.macro '$args -> $(result :: type_expr_meta.AfterInfixParsed('->')) $()':
  ~op_stx self
  ~associativity ~right
  ~weaker_than *
  let r_ty: extract_parsed(result)
  values(match type_expr_meta.unpack(args)
         | ps :: t.ParenOf:
             type_expr_meta.pack(t.Arrow(self, ps.args, r_ty))
         | arg:
             type_expr_meta.pack(t.Arrow(self, [arg], r_ty)),
         '$result.tail ...')

type_expr.macro '$init * $(next :: type_expr_meta.AfterInfixParsed('*')) $()':
  ~op_stx self
  let init_ty: extract_parsed(init)
  let next_ty: extract_parsed(next)
  recur loop (args = [next_ty, init_ty],
              src = '$init $self $next',
              tail = '$next.tail ...'):
    match tail:
    | ('$op $tail ...' where '$(bound_as type_expr_meta.space: '*')' = op):
        let '$(next :: type_expr_meta.AfterInfixParsed('*'))' = '$tail ...'
        loop([extract_parsed(next), & args],
             '$src $op $next',
             '$next.tail ...')
    | ~else:
        values(type_expr_meta.pack(t.TupleOf(src, List.reverse(args))),
               tail)

meta:
  fun parse(stx, src :: Syntax, tvars_box, lookup_type, lookup_tvar):
    parameterize { current_tvars_box: tvars_box,
                   current_type_lookup: lookup_type,
                   current_tvar_lookup: lookup_tvar}:      
      match stx
      | '': t.gen_tvar(src)
      | '$(t :: ParsedType)':
          t.type
