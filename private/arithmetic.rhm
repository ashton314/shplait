#lang rhombus/static/and_meta
import:
  meta:
    "type.rhm" as t
  "frame.rhm" as f
  "type_statinfo.rhm" as t_s
  "lazy.rhm" open
  "wrap.rhm" open

decl.macro 'def_binary $name $op $type_constr: $option; ...':
  '«export: rename: $name as $op
    expr.macro '$('$')left $name $('$')right':
      ~op_stx self
      $option
      ...
      t.unify_do(left, t_s.lookup_type(left, #false), t.Num(self))
      t.unify_do(right, t_s.lookup_type(right, #false), t.Num(self))
      t_s.wrap_type('force($('$')left) $('$')('$op'.relocate(self)) force($('$')right)',
                    t. $type_constr ('$('$')left $('$')self $('$')right'))»'

def_binary shplus + Num:
  ~weaker_than shtimes shdiv shmod
  ~same_as shminus
def_binary shminus - Num:
  ~weaker_than shtimes shdiv shmod
def_binary shtimes * Num:
  ~same_on_left_as shdiv shmod
def_binary shdiv / Num:«»
def_binary shmod mod Num:«»

def_binary shlt < Bool:
  ~weaker_than shplus shminus shtimes shdiv shmod
def_binary shgt > Bool:
  ~weaker_than shplus shminus shtimes shdiv shmod
def_binary sgle <= Bool:
  ~weaker_than shplus shminus shtimes shdiv shmod
def_binary shge >= Bool:
  ~weaker_than shplus shminus shtimes shdiv shmod

export: rename: _not as !
expr.macro '_not $right':
  ~op_stx self
  t.unify_do(right, t_s.lookup_type(right, #false), t.Bool(self))
  t_s.wrap_type('! force($right)', t.Bool('$self $right'))

decl.macro 'def_equality $op $type_constr':
  '«export: rename: equals as $op
    expr.macro '$('$')left equals $('$')right':
      ~op_stx self
      ~weaker_than shplus shminus shtimes shdiv shmod
      let tv = t.gen_tvar(self)
      t.unify_do(left, t_s.lookup_type(left, #false), tv)
      t.unify_do(right, t_s.lookup_type(right, #false), tv)
      t_s.wrap_type('force_all($('$')left) $('$')('$op'.relocate(self)) force_all($('$')right)',
                    t.Bool(self))»'

def_equality ==
def_equality !=
def_equality ===

export:
  rename:
    shand as &&
    shor as ||

meta:
  fun parse_bool(left, right, self, op :: Syntax):
    let bool = t.Bool(self)
    t.unify_do(self, t_s.lookup_type(left, #false), bool)
    t.unify_do(self, t_s.lookup_type(right, #false), bool)
    t_s.wrap_type('force($left) $(op.relocate(self)) force($right)',
                  bool)

expr.macro '$left shand $right':
  ~op_stx self
  ~stronger_than: shor
  ~weaker_than: ~other
  parse_bool(left, right, self, '&&')

expr.macro '$left shor $right':
  ~op_stx self
  ~weaker_than: ~other
  parse_bool(left, right, self, '||')

export: rename: concat as +&
expr.macro '$left concat $right':
  ~op_stx self
  t_s.wrap_type('force($left) $('+&'.relocate(self)) force($right)',
                t.Str(self))

export:
  rename:
    shmin as min
    shmax as max
    shfloor as floor
    shceiling as ceiling

defwrap wrap_min min(a, b): math.min(dynamic_force(a), dynamic_force(b))
defwrap wrap_max max(a, b): math.max(dynamic_force(a), dynamic_force(b))
defwrap wrap_floor floor(a): math.floor(dynamic_force(a))
defwrap wrap_ceiling ceiling(a): math.ceiling(dynamic_force(a))

expr.macro 'shmin':
  ~op_stx self
  t_s.wrap_type('wrap_min', t.Arrow(self, [t.Num(self), t.Num(self)], t.Num(self)))
expr.macro 'shmax':
  ~op_stx self
  t_s.wrap_type('wrap_max', t.Arrow(self, [t.Num(self), t.Num(self)], t.Num(self)))
expr.macro 'shfloor':
  ~op_stx self
  t_s.wrap_type('wrap_floor', t.Arrow(self, [t.Num(self)], t.Num(self)))
expr.macro 'shceiling':
  ~op_stx self
  t_s.wrap_type('wrap_ceiling', t.Arrow(self, [t.Num(self)], t.Num(self)))
