#lang rhombus/static/and_meta
import:
  meta:
    "type.rhm" as t
    "id_map.rhm" open
    "box.rhm" open
  "argument.rhm" open
  "frame.rhm" as f
  "type_statinfo.rhm" as t_s
  "unify.rhm".unify
  "value.rhm".value_meta
  "value.rhm".current_value_tvar_box
  "block.rhm".block
  "tuple.rhm"!tuple as tu

export:
  rename:
    define as def

meta:
  fun build_def(self, [id, ...], [type_seq, ...], rhs):
    let [tmp, ...] = [Syntax.make_temp_id(id), ...]
    let tvar_box = Box(IdMap{})
    let poly_context = f.get_current_frame().poly_context
    let base_tvars = f.get_current_frame().all_tvars()
    let (mode, [ty, ...]):
      parameterize { current_value_tvar_box: tvar_box }:
        fun default():
          values('', [t.as_non_poly(f.parse_type(type_seq, id, tvar_box),
                                    poly_context,
                                    base_tvars),
                      ...])
        match [type_seq, ...]
        | ['']:
            match rhs
            | '$(v :: value_meta.Parsed)' when v.unwrap():
                values('~defn',
                       [t.create_defn(t_s.syntax_to_type(v),
                                      poly_context,
                                      base_tvars,
                                      IdMap.val_set(tvar_box.val))])
            | ~else default()
        | ~else default()
    let [ty_sym, ...] = [t_s.type_to_syntax(ty), ...]
    Function.pass(f.record_frame_defn_type(ty_sym, ty), ...)
    let { tv_id: tv_ty, ... } = IdMap.flatten(tvar_box.val)
    let (tuple_lhs, tuple_ty):
      match [[id, ...], [ty, ...]]:
      | [[id], [ty]]: values(id, ty)
      | _: values('tu.Tuple([$id, ...])', t.TupleOf(self, [ty, ...]))
    '«statinfo.macro '$id': '(($t_s.type_key,
                               $ty_sym))'
      ...
      def $tuple_lhs:
        dynamic(unify ~defn $(t_s.type_to_syntax(tuple_ty)):
                  ~self: $self
                  ~init_tvars: [($tv_id, $(t_s.type_to_syntax(tv_ty))), ...]
                  ~defns:«»
                  ~body:
                    $rhs)»'

meta:
  syntax_class LHS:
    fields:
      [id, ...]
      [type_seq, ...]
  | 'values ($(one_arg ::Argument), ...)':
      field [id, ...] = [one_arg.id, ...]
      field [type_seq, ...] = [one_arg.type_seq, ...]
  | '$(arg ::Argument)':
      field [id, ...] = [arg.id]
      field [type_seq, ...] = [arg.type_seq]

defn.macro
| 'define $(lhs :: LHS) $(eql && '=') $rhs':
    ~op_stx self
    build_def(self, [lhs.id, ...], [lhs.type_seq, ...], rhs)
| 'define $(lhs :: LHS): $(rhs :: Group)':
    ~op_stx self
    build_def(self, [lhs.id, ...], [lhs.type_seq, ...], rhs)
| 'define $(lhs :: LHS): $block':
    ~op_stx self
    build_def(self, [lhs.id, ...], [lhs.type_seq, ...],
              // this is Shplait's `block`:
              'block: $block')
