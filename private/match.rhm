#lang rhombus/static/and_meta
import:
  meta:
    "type.rhm" as t
    "id_map.rhm" open
  "pattern.rhm".pattern_meta
  "type_statinfo.rhm" as t_s
  "unify.rhm".unify
  "list.rhm".cons

export:
  rename:
    shmatch as match

meta:
  syntax_class ListClauses:
    fields:
      empty_body
      f_id
      r_id
      cons_body
  | '| []: $(empty_body :: Group)
     | $(bound_as expr_meta.space: 'cons')($(f_id :: Identifier), $(r_id :: Identifier)): $(cons_body :: Group)'
  | '| $(bound_as expr_meta.space: 'cons')($(f_id :: Identifier), $(r_id :: Identifier)): $(cons_body :: Group)
     | []: $(empty_body :: Group)'
  | '| []: $(empty_body :: Group)
     | ~else: $(cons_body :: Group)':
      field f_id: 'f'
      field r_id: 'r'
  | '| $(bound_as expr_meta.space: 'cons')($(f_id :: Identifier), $(r_id :: Identifier)): $(cons_body :: Group)
     | ~else: $(empty_body :: Group)'

expr.macro
| 'shmatch $expr ... $(lcs :: ListClauses)':
    ~op_stx self
    parse_list_match(self,
                     '$expr ...',
                     lcs.empty_body,
                     lcs.f_id, lcs.r_id, lcs.cons_body)
| 'shmatch $expr ...
   | $(ctr :: Identifier) ($(field :: Identifier), ...):
       $(body :: Group)
   | ...
   | ~else:
       $(else_body :: Group)':
    ~op_stx self
    parse_match(self,
                '$expr ...',
                [[ctr, [field, ...]], ...],
                [body, ...],
                else_body)
| 'shmatch $expr ...
   | $(ctr :: Identifier) ($(field :: Identifier), ...):
       $(body :: Group)
   | ...':
    ~op_stx self
    parse_match(self,
                '$expr ...',
                [[ctr, [field, ...]], ...],
                [body, ...],
                #false)
| 'shmatch $x ...':
    ~op_stx self
    syntax_meta.error("bad syntax", '$self $x ...')

meta:
  fun parse_list_match(self,
                       expr_in,
                       empty_body,
                       f_id, r_id, cons_body):
    let '$(expr :: expr_meta.Parsed)' = expr_in
    let elem_tv = t.gen_tvar(self)
    t.unify_do(expr_in, t_s.lookup_type(expr), t.ListOf(self, elem_tv))
    let tv = t.gen_tvar(self)
    let r:
      '«match $expr
        | []: unify ~expr $(t_s.type_to_syntax(tv)):
                ~self:
                  $self
                ~init_tvars: []
                ~defns:«»
                ~body:
                  $empty_body 
        | [first, & rest]:
            def $f_id = first
            def $r_id = rest
            statinfo.macro '$f_id': '(($t_s.type_key, $(t_s.type_to_syntax(elem_tv))))'
            statinfo.macro '$r_id': '(($t_s.type_key, $(t_s.type_to_syntax(t.ListOf(self, elem_tv)))))'
            unify ~expr $(t_s.type_to_syntax(tv)):
              ~self:
                  $self
              ~init_tvars: []
              ~defns:«»
              ~body:
                $cons_body»'
    t_s.wrap_type(r, tv)


  fun parse_match(self,
                  expr_in,
                  [[ctr, [field, ...]], ...],
                  [body, ...],
                  else_body):
    let '$(expr :: expr_meta.Parsed)' = expr_in
    let [[dt_id, dt_n, pat_id, [pat_ty, ...]], ...]:
      for List:
        each ctr: [ctr, ...]
        match ctr
        | '$(pat :: pattern_meta.Parsed)':
            pattern_meta.unpack(pat)
        | ~else syntax_meta.error("expected a variant name", self, ctr)
    let the_dt_id = [dt_id, ...][0]    
    for values(seen = IdMap{}):
      each:
        ctr: [ctr, ...]
        dt_id: [dt_id, ...]
      unless syntax_meta.equal_binding(dt_id, the_dt_id)
      | syntax_meta.error("variant not from the same type as earlier variants", self, ctr)
      when seen[ctr]
      | syntax_meta.error("duplicate case for variant", self, ctr)
      seen ++ IdMap{ ctr: #true }
    t.unify_do(self, t_s.lookup_type(expr), t.Datatype(self, the_dt_id, []))
    if else_body
    | when [dt_n, ...][0] == [dt_n, ...].length():
      | syntax_meta.error("else case is unreachable", self)
    | unless [dt_n, ...][0] == [dt_n, ...].length()
      | syntax_meta.error("missing at least one variant case", self)
    let [[arg_id, ...], ...] = [[Syntax.make_temp_id(pat_ty), ...], ...]
    for:
      each:
        ctr: [ctr, ...]
        pat_id: [pat_id, ...]
        [pat_ty, ...]: [[pat_ty, ...], ...]
        [field, ...]: [[field, ...], ...]
      when [pat_ty, ...].length() != [field, ...].length()
      | syntax_meta.error("wrong field count", self, ctr)
    let tv = t.gen_tvar(self)
    let [[field_tv, ...], ...] = [[t.gen_tvar(field), ...], ...]
    Function.pass(t.unify_do(field, field_tv, pat_ty), ..., ...)
    let [else, ...]:
      if else_body
      | ['~else:
            unify ~expr $(t_s.type_to_syntax(tv)):
              ~self: $self
              ~init_tvars: []
              ~defns:«»
              ~body:
                $else_body']
      | []
    let r:
      '«match $expr
        | $pat_id($arg_id, ...):
            def $field = $arg_id
            ...
            statinfo.macro '$field': '(($t_s.type_key, $(t_s.type_to_syntax(field_tv))))'
            ...
            unify ~expr $(t_s.type_to_syntax(tv)):
              ~self:
                  $self
              ~init_tvars: []
              ~defns:«»
              ~body:
                $body
        | ...
        | $else
        | ...»'
    t_s.wrap_type(r, tv)
